<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Fed_WSVAD Documentation</title>
  <link id="hljs-light" rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/github.min.css" />
  <link id="hljs-dark" rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/github-dark.min.css"
    disabled />
  <link href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@400..700&display=swap" rel="stylesheet">

  <style>
    /* —— Color Variables —— */
    :root {
      --bg: #ffffff;
      --text: #24292e;
      --sidebar-bg: #fdfdfd;
      --sidebar-border: #e1e4e8;
      --link: #0366d6;
      --link-hover: #024ea2;
      --active-bg: #e7f4ff; /* A slightly lighter blue for active items */
      --code-bg: #f6f8fa;
      --code-border: #e1e4e8;
      --btn-bg: #0366d6;
      --btn-text: #ffffff;
      --btn-hover: #024ea2;
      --footer-text: #57606a;
      --transition: 0.2s ease-in-out;
      --img-shadow: rgba(0,0,0,0.1);

      /* Table Specific Colors (New/Adjusted) */
      --table-border: #c6cbd1; /* Darker border for tables */
      --table-header-bg: #f0f3f6; /* Slightly darker header background */
      --table-row-even-bg: #f6f8fa; /* Slightly darker zebra stripe */
    }

    body.dark {
      --bg: #0d1117;
      --text: #c9d1d9;
      --sidebar-bg: #161b22;
      --sidebar-border: #30363d;
      --link: #58a6ff;
      --link-hover: #4191db;
      --active-bg: #1f6feb33; /* A subtle blue highlight for dark mode */
      --code-bg: #161b22;
      --code-border: #30363d;
      --btn-bg: #238636;
      --btn-text: #ffffff;
      --btn-hover: #196e2d;
      --footer-text: #8b949e;
      --img-shadow: rgba(0,0,0,0.3);

      /* Table Specific Colors (Dark Mode) (New/Adjusted) */
      --table-border: #444c56; /* Darker border for tables in dark mode */
      --table-header-bg: #21262d; /* Darker header background in dark mode */
      --table-row-even-bg: #1c222b; /* Darker zebra stripe in dark mode */
    }

    /* —— Base Styles —— */
    * {
      box-sizing: border-box;
      transition: background-color var(--transition),
        color var(--transition), border-color var(--transition); /* Added border-color to transition */
    }

    body {
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica,
        Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"; /* Added emoji fonts */
      font-size: 16px;
      line-height: 1.7; /* Increased for better readability */
      color: var(--text);
      background-color: var(--bg);
      display: flex; /* Use flexbox for main layout */
      height: 100vh;
      overflow: hidden; /* Hide overflow on body to manage scrolling on #content */
    }

    /* —— Sidebar —— */
    #sidebar {
      position: fixed; /* Keep fixed position */
      top: 0;
      left: 0;
      bottom: 0;
      width: 260px; /* Fixed width sidebar */
      background-color: var(--sidebar-bg);
      border-right: 1px solid var(--sidebar-border);
      display: flex;
      flex-direction: column;
      overflow-y: auto;
      padding: 1.5rem 1rem; /* Adjusted padding */
      flex-shrink: 0; /* Prevent sidebar from shrinking in flex layout */
    }

    #navList {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    #navList li {
      margin: 0.6rem 0; /* Increased spacing between items */
    }

    #navList a, #navList .folder {
      display: block;
      text-decoration: none;
      color: var(--link);
      padding: 0.5rem 0.8rem; /* Increased padding for better touch targets */
      border-radius: 6px; /* Slightly more rounded corners */
      font-weight: 500;
      word-wrap: break-word; /* Ensure long text wraps */
    }
      #navList .folder {
        color: var(--text); /* Folder text color same as body text */
        font-weight: 600; /* Make folder names bolder */
        cursor: default;
      }


    #navList a:hover {
      background-color: var(--active-bg);
      color: var(--link-hover);
    }

    #navList a.active {
      background-color: var(--active-bg);
      color: var(--link-hover); /* Ensure text color changes for active link */
      font-weight: 700; /* Bolder active link */
    }

    #navList ul {
      margin-left: 1.2rem; /* Slightly increased indent for sub-items */
      padding-left: 0.5rem;
      border-left: 1px solid var(--sidebar-border);
    }
      #navList ul li {
        margin: 0.4rem 0;
      }

    .maintainer {
      margin-top: auto;
      padding-top: 1.5rem; /* Increased padding */
      font-size: 1.1rem; /* Slightly larger maintainer text */
      color: var(--footer-text);
      text-align: left;
      padding-left: 0.8rem; /* Align with nav items */
      font-family: 'Dancing Script', cursive; /* Apply cursive font */
      font-weight: 700; /* Make it a bit bolder if the font supports it */
    }

    /* —— Theme Toggle Button —— */
    #themeToggle {
      position: fixed;
      top: 1rem;
      right: 1rem;
      z-index: 1000;
      border: 1px solid var(--sidebar-border); /* Added border for definition */
      background-color: var(--sidebar-bg); /* Use sidebar background */
      color: var(--text); /* Use body text color */
      width: 40px; /* Slightly larger */
      height: 40px; /* Slightly larger */
      border-radius: 50%;
      font-size: 20px; /* Slightly larger icon */
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background-color var(--transition), color var(--transition), border-color var(--transition), transform 0.1s ease;
    }

    #themeToggle:hover {
      background-color: var(--code-bg); /* Use code background for hover */
      border-color: var(--link);
    }
    #themeToggle:active {
        transform: scale(0.95);
    }


    /* —— Content Area (Full width next to sidebar, handles scrolling) —— */
    #content {
      flex-grow: 1; /* Allow content to grow and fill space */
      overflow-y: auto; /* Add scrollbar to this area */
      padding: 0; /* Remove padding here, apply to wrapper */
      margin-left: 260px; /* Push content area next to sidebar */
      display: flex; /* Use flexbox column to stack badges and wrapper */
      flex-direction: column;
      /* Removed align-items: center; to allow badge container to align left */
    }

    /* —— Badges Container from README (Direct child of #content) —— */
    .md-badges {
      display: flex; /* Use flexbox for layout */
      justify-content: flex-start; /* Align badges to the left */
      align-items: center; /* Center badges vertically */
      gap: 0; /* Remove space between badges */
      margin: 1.5em 0; /* Add vertical margin */
      width: auto; /* Allow badge container to take only necessary width */
      padding: 0 2.5rem; /* Add horizontal padding to align with content wrapper padding */
      box-sizing: border-box; /* Include padding in width calculation */
      align-self: flex-start; /* Align the badge container to the start (left) within #content */
    }

    .md-badges img {
        /* Override general .content-wrapper img styles for badges */
        max-width: none; /* Ensure original size */
        height: auto; /* Maintain aspect ratio */
        display: inline-block; /* Ensure inline-block behavior */
        margin: 0; /* Remove any default image margins */
        border-radius: 4px; /* Keep styles from snippet */
        box-shadow: 0 2px 6px rgba(0,0,0,0.15); /* Keep styles from snippet */
        background-color: transparent; /* Ensure no background interferes */
        /* Increase size - setting a height will scale proportionally */
        height: 80px; /* Approximate 5x increase from typical badge height */
    }

    .md-badges a {
        text-decoration: none; /* Remove underline from badge links */
    }


    /* —— Content Wrapper (Centers content within #content) —— */
    .content-wrapper {
      max-width: 75%; /* Limit content width to 75% of #content */
      width: 100%; /* Allow wrapper to take full width up to max-width */
      padding: 0 2.5rem; /* Apply horizontal padding here */
      padding-top: 0; /* Remove top padding here, handled by badge margin */
      padding-bottom: 2rem; /* Add bottom padding */
      box-sizing: border-box; /* Include padding in width calculation */
      flex-shrink: 0; /* Prevent wrapper from shrinking */
      align-self: center; /* Center the content wrapper horizontally within #content */
    }


    .content-wrapper h1,
    .content-wrapper h2,
    .content-wrapper h3,
    .content-wrapper h4,
    .content-wrapper h5,
    .content-wrapper h6 {
      margin-top: 2em;    /* Increased top margin for headings */
      margin-bottom: 1em; /* Increased bottom margin for headings */
      font-weight: 600;
      line-height: 1.3;   /* Adjusted line-height for headings */
    }

    .content-wrapper h1 {
      font-size: 2.2em; /* Slightly larger H1 */
      border-bottom: 1px solid var(--sidebar-border);
      padding-bottom: 0.4em;
    }

    .content-wrapper h2 {
      font-size: 1.8em; /* Slightly larger H2 */
        border-bottom: 1px dashed var(--sidebar-border); /* Subtle separator for H2 */
        padding-bottom: 0.3em;
    }
    .content-wrapper h3 {
        font-size: 1.4em;
    }


    .content-wrapper p {
      margin: 0 0 1.2em 0; /* Consistent bottom margin for paragraphs */
    }

    /* —— Code & Preformatted Blocks —— */
    .content-wrapper pre {
      background-color: var(--code-bg);
      border: 1px solid var(--code-border);
      padding: 1.2rem; /* Increased padding */
      border-radius: 8px; /* More rounded corners */
      position: relative;
      overflow-x: auto;
      margin: 1.5em 0; /* Added vertical margin */
    }

    .content-wrapper code:not(pre code) { /* Inline code */
      background-color: var(--code-bg);
      padding: 0.2em 0.4em;
      border-radius: 4px;
      font-size: 0.9em;
      border: 1px solid var(--code-border);
    }
    .content-wrapper pre code { /* Code within pre blocks */
      font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace; /* Common monospace stack */
      font-size: 0.95em;
      background-color: transparent; /* No background for code inside pre */
      border: none;
      padding: 0;
    }


    .copy-btn {
      position: absolute;
      top: 10px; /* Adjusted position */
      right: 10px; /* Adjusted position */
      background: var(--btn-bg);
      color: var(--btn-text);
      border: none;
      padding: 6px 10px; /* Adjusted padding */
      font-size: 13px; /* Adjusted font size */
      border-radius: 5px; /* Adjusted border radius */
      cursor: pointer;
      opacity: 0.7; /* Slightly transparent by default */
      transition: background-color var(--transition), color var(--transition), opacity 0.15s ease;
    }
    .content-wrapper pre:hover .copy-btn {
        opacity: 1; /* Fully visible on pre hover */
    }

    .copy-btn:hover {
      background: var(--btn-hover);
      opacity: 1;
    }
    .copy-btn.copied { /* Style for when button is clicked */
        background: #28a745; /* Green for success */
        color: white;
    }


    /* —— Links, Tables, Blockquotes —— */
    .content-wrapper a {
      color: var(--link);
      text-decoration: none; /* Remove underline by default */
    }

    .content-wrapper a:hover {
      text-decoration: underline; /* Underline on hover */
      color: var(--link-hover);
    }

    .content-wrapper table {
      border-collapse: collapse;
      width: 100%;
      margin: 1.8em 0; /* Added vertical margin */
      box-shadow: 0 2px 4px var(--img-shadow); /* Subtle shadow for tables */
      border-radius: 6px; /* Rounded corners for table wrapper (if any) or via cells */
      overflow: hidden; /* Needed for border-radius on table */
    }

    .content-wrapper th,
    .content-wrapper td {
      border: 1px solid var(--table-border); /* Use new table border variable */
      padding: 0.8em 1.2em; /* Adjusted padding */
      text-align: left; /* Ensure text is left-aligned */
    }
    .content-wrapper th {
        background-color: var(--table-header-bg); /* Use new table header background variable */
        font-weight: 600;
    }
    .content-wrapper tr:nth-child(even) {
        background-color: var(--table-row-even-bg); /* Use new zebra stripe background variable */
    }


    .content-wrapper blockquote {
      border-left: 5px solid var(--link); /* Use link color for border */
      padding: 1em 1.5em; /* Adjusted padding */
      margin: 1.8em 0; /* Adjusted margin */
      background-color: var(--code-bg);
      border-radius: 0 6px 6px 0; /* Rounded corners on one side */
      color: var(--footer-text); /* Softer text color for blockquotes */
    }
    .content-wrapper blockquote p:last-child {
        margin-bottom: 0; /* Remove bottom margin from last p in blockquote */
    }

    /* —— Images (including SVG) —— */
    .content-wrapper img { /* General image styling */
      max-width: 55%; /* Limit images to 55% of its container width */
      height: auto;
      display: block;
      margin: 1.5em auto; /* Centered with vertical margin */
      border-radius: 8px; /* Rounded corners for images */
      box-shadow: 0 4px 12px var(--img-shadow); /* Softer, more diffused shadow */
      background-color: var(--bg); /* Add background for transparent images */
    }

  </style>
</head>
<body>
  <nav id="sidebar">
    <div class="nav-container">
      <ul id="navList">
        <li><a href="#README.md">Home</a></li>
        <li><span class="folder">Backbone</span>
          <ul>
            <li><a href="#Backbone/README.md">Feature Extraction Guide (VideoMAE V2 Backbone)</a></li>
          </ul>
        </li>
        <li><span class="folder">Fed_VAD</span>
          <ul>
            <li><a href="#Fed_VAD/README.md">Federated Setup (Fed-WSVAD)</a></li>
            <li><a href="#Fed_VAD/Jetson%20AGX%20Xavier%20Deployment%20Guide.md">Jetson AGX Xavier Deployment Guide</a></li>
          </ul>
        </li>
        <li><a href="https://deepwiki.com/rekkles2/Fed_WSVAD" target="_blank" rel="noopener noreferrer">DeepWiki Code Navigator</a></li>
      </ul>
    </div>
    <div class="maintainer">Maintained by Jiahang Li</div>
  </nav>

  <button id="themeToggle" aria-label="Toggle dark/light mode">🌙</button>

  <main id="content">
    <div class="content-wrapper">
      <p>Loading...</p>
    </div>
  </main>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/15.0.7/marked.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js"></script>
  <script>
    // --- Theme Toggle Functionality ---
    const themeToggleBtn = document.getElementById('themeToggle');
    const lightStyle = document.getElementById('hljs-light');
    const darkStyle = document.getElementById('hljs-dark');
    const savedTheme = localStorage.getItem('theme');

    function applyTheme(theme) {
      if (theme === 'dark') {
        document.body.classList.add('dark');
        if (lightStyle) lightStyle.disabled = true;
        if (darkStyle) darkStyle.disabled = false;
        themeToggleBtn.textContent = '☀️'; // Sun icon for dark mode
      } else {
        document.body.classList.remove('dark');
        if (lightStyle) lightStyle.disabled = false;
        if (darkStyle) darkStyle.disabled = true;
        themeToggleBtn.textContent = '🌙'; // Moon icon for light mode
      }
    }

    // Apply saved theme or system preference on load
    applyTheme(savedTheme || (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light'));

    // Event listener for theme toggle button
    themeToggleBtn.addEventListener('click', () => {
      const newTheme = document.body.classList.contains('dark') ? 'light' : 'dark';
      applyTheme(newTheme);
      localStorage.setItem('theme', newTheme);
    });

    // --- Markdown Loading and Processing ---
    const contentDiv = document.getElementById('content');
    const contentWrapperDiv = contentDiv.querySelector('.content-wrapper');
    let currentFile = null; // Tracks the currently loaded markdown file
    const GITHUB_REPO_RAW_BASE_URL = 'https://raw.githubusercontent.com/rekkles2/Fed_WSVAD/main/';
    const HOME_README_URL = 'https://raw.githubusercontent.com/rekkles2/page/main/README.md';


    // Generates a valid HTML ID from a string (e.g., for heading anchors)
    function generateValidId(input) {
        return input.trim().toLowerCase()
                    .replace(/[^\w\s-]/g, '') // Remove non-alphanumeric (except hyphen, underscore)
                    .replace(/\s+/g, '-')    // Replace spaces with hyphens
                    .replace(/-+/g, '-');   // Replace multiple hyphens with single
    }

    // Fetches and renders Markdown content
    async function loadMarkdown(filePath) {
      // Clear previous content and display loading message
      contentWrapperDiv.innerHTML = '<p>Loading content...</p>';
      // Remove any previously extracted badges
      const oldBadges = contentDiv.querySelector('.md-badges');
      if (oldBadges) {
          oldBadges.remove();
      }


      try {
        // Determine the correct URL for the markdown file
        const isHomePage = filePath === 'README.md';
        const fileUrl = isHomePage ? HOME_README_URL : GITHUB_REPO_RAW_BASE_URL + filePath;
        const response = await fetch(fileUrl);

        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status} for ${fileUrl}`);
        }
        const markdownText = await response.text();

        // Parse Markdown to HTML using 'marked' library
        let parsedHtml = marked.parse(markdownText);

        // Use a temporary div to extract the badges before inserting the rest of the HTML
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = parsedHtml;
        const badgeDiv = tempDiv.querySelector('.md-badges');

        if (badgeDiv) {
            // Remove the badge div from the temporary HTML string
            badgeDiv.remove();
             // Insert the extracted badge div directly into #content before the wrapper
            contentDiv.insertBefore(badgeDiv, contentWrapperDiv);

             // Ensure badge links open in a new tab
            badgeDiv.querySelectorAll('a').forEach(badgeLink => {
                const href = badgeLink.getAttribute('href');
                if (href && (href.startsWith('http://') || href.startsWith('https://'))) {
                     try {
                        const linkUrl = new URL(badgeLink.href); // Use badgeLink.href to get absolute URL
                        const currentLocUrl = new URL(window.location.href);
                        if (linkUrl.hostname !== currentLocUrl.hostname || linkUrl.protocol !== currentLocUrl.protocol) {
                            badgeLink.setAttribute('target', '_blank');
                            badgeLink.setAttribute('rel', 'noopener noreferrer');
                        }
                    } catch (e) {
                        console.error("Error processing badge link URL for target='_blank':", href, e);
                         badgeLink.setAttribute('target', '_blank');
                         badgeLink.setAttribute('rel', 'noopener noreferrer');
                    }
                }
            });

        }

        // Insert the remaining parsed HTML (without badges) into the content wrapper
        contentWrapperDiv.innerHTML = tempDiv.innerHTML;


        // --- Link Handling ---
        // Determine the base URL for resolving relative links within the current markdown file
        const currentFileDirectory = filePath.includes('/') ? filePath.substring(0, filePath.lastIndexOf('/') + 1) : '';
        const baseUrlForRelativeLinks = (isHomePage) ?
                                       new URL(HOME_README_URL).href.substring(0, new URL(HOME_README_URL).href.lastIndexOf('/') + 1) : // Base of the 'page' repo
                                       new URL(currentFileDirectory, GITHUB_REPO_RAW_BASE_URL).href;


        contentWrapperDiv.querySelectorAll('a').forEach(link => {
          const href = link.getAttribute('href');
          if (href) {
            // Handle relative links (not starting with #, http, mailto)
            if (!href.startsWith('#') && !href.startsWith('http://') && !href.startsWith('https://') && !href.startsWith('mailto:')) {
              const parts = href.split('#');
              const pathPart = parts[0];
              const internalHashPart = parts.length > 1 ? '#' + parts.slice(1).join('#') : '';

              if (pathPart.toLowerCase().endsWith('.md')) {
                // Convert relative .md links to internal hash links for SPA navigation
                let absolutePath;
                // Resolve relative path based on the current markdown file's directory
                absolutePath = new URL(pathPart, baseUrlForRelativeLinks).pathname;
                // Make path relative to GITHUB_REPO_RAW_BASE_URL's path part if it's not the home page
                 if (!isHomePage) {
                     let baseRepoPath = new URL(GITHUB_REPO_RAW_BASE_URL).pathname;
                     if (absolutePath.startsWith(baseRepoPath)) {
                        absolutePath = absolutePath.substring(baseRepoPath.length);
                     }
                 }
                 absolutePath = absolutePath.replace(/^\//, ''); // Ensure no leading slash for hash

                link.setAttribute('href', '#' + absolutePath + internalHashPart); // Use original path in hash

              } else {
                // Convert other relative links (assets, etc.) to absolute raw GitHub URLs
                const absoluteUrl = new URL(href, baseUrlForRelativeLinks).href;
                link.setAttribute('href', absoluteUrl);
                link.setAttribute('target', '_blank'); // Open asset links in new tab
                link.setAttribute('rel', 'noopener noreferrer');
              }
            } else if (href.startsWith('https://github.com/rekkles2/Fed_WSVAD/blob/main/')) {
              // Convert GitHub blob links to internal hash links
              const repoPathWithHash = href.substring('https://github.com/rekkles2/Fed_WSVAD/blob/main/'.length);
              const parts = repoPathWithHash.split('#');
              const pathPart = parts[0];
              const internalHashPart = parts.length > 1 ? '#' + parts.slice(1).join('#') : '';
              link.setAttribute('href', '#' + pathPart + internalHashPart);
            }
            // Ensure all external HTTP/HTTPS links open in a new tab
             if ((href.startsWith('http://') || href.startsWith('https://')) && !link.getAttribute('href').startsWith('#')) {
                // Check if it's not already targeting _blank and not an internal SPA link
                if (link.getAttribute('target') !== '_blank') {
                    try {
                        const linkUrl = new URL(link.href); // Use link.href to get absolute URL
                        const currentLocUrl = new URL(window.location.href);
                        if (linkUrl.hostname !== currentLocUrl.hostname || linkUrl.protocol !== currentLocUrl.protocol) {
                            link.setAttribute('target', '_blank');
                            link.setAttribute('rel', 'noopener noreferrer');
                        }
                    } catch (e) {
                        console.error("Error processing link URL for target='_blank':", href, e);
                        // Fallback for potentially malformed relative links that became absolute
                        if (!link.href.startsWith(window.location.origin + window.location.pathname)) {
                             link.setAttribute('target', '_blank');
                             link.setAttribute('rel', 'noopener noreferrer');
                        }
                    }
                }
            }
          }
        });

        // Add IDs to headings for deep linking if not already present
        contentWrapperDiv.querySelectorAll('h1, h2, h3, h4, h5, h6').forEach(heading => {
          if (!heading.id) {
            heading.id = generateValidId(heading.textContent.trim());
          }
        });

        // Add "Copy" buttons to code blocks
        contentWrapperDiv.querySelectorAll('pre').forEach(preElement => {
          if (preElement.querySelector('code') && !preElement.querySelector('.copy-btn')) {
            const copyButton = document.createElement('button');
            copyButton.className = 'copy-btn';
            copyButton.textContent = 'Copy';
            copyButton.setAttribute('aria-label', 'Copy code to clipboard');
            copyButton.onclick = () => {
              const codeToCopy = preElement.querySelector('code').innerText;
              navigator.clipboard.writeText(codeToCopy).then(() => {
                copyButton.textContent = 'Copied!';
                copyButton.classList.add('copied');
                setTimeout(() => {
                  copyButton.textContent = 'Copy';
                  copyButton.classList.remove('copied');
                }, 2000);
              }).catch(err => {
                console.error('Failed to copy text: ', err);
                copyButton.textContent = 'Error';
                setTimeout(() => { copyButton.textContent = 'Copy'; }, 2000);
              });
            };
            preElement.appendChild(copyButton);
          }
        });

        // Apply syntax highlighting using highlight.js
        if (typeof hljs !== 'undefined') {
            hljs.highlightAll();
        }


        // Update active link in the sidebar navigation
        document.querySelectorAll('#navList a').forEach(navLink => {
          const navHref = navLink.getAttribute('href');
          // Only apply 'active' to internal hash links
          if (navHref && navHref.startsWith('#')) {
            const navFilePath = navHref.substring(1).split('#')[0]; // Compare file path part of the hash
            navLink.classList.toggle('active', navFilePath === filePath);
          } else {
            navLink.classList.remove('active'); // External links should not be marked active
          }
        });

        // Scroll to the top of the content or to a specific section if a hash is present
        const urlHash = window.location.hash;
        if (urlHash) {
          const hashContent = decodeURIComponent(urlHash.slice(1));
          const hashParts = hashContent.split('#');
          const filePartOfHash = hashParts[0]; // e.g., README.md or Backbone/README.md
          const sectionHashPart = hashParts.length > 1 ? hashParts[1] : ''; // e.g., introduction

          // Only scroll if the file part of the hash matches the currently loaded file
          if (filePartOfHash === filePath && sectionHashPart) {
            const elementToScroll = contentWrapperDiv.querySelector('#' + generateValidId(sectionHashPart));
            if (elementToScroll && contentWrapperDiv.contains(elementToScroll)) {
              elementToScroll.scrollIntoView({ behavior: 'smooth' });
            } else {
              console.warn(`Element with ID #${generateValidId(sectionHashPart)} not found in ${filePath}.`);
              contentDiv.scrollTop = 0; // Scroll to top if section not found
            }
          } else if (filePartOfHash === filePath) { // File matches, but no specific section
            contentDiv.scrollTop = 0;
          }
          // If filePartOfHash does not match filePath, scrolling is handled by the new page load.
        } else {
          contentDiv.scrollTop = 0; // Scroll to top if no hash at all
        }

        currentFile = filePath; // Update the currently loaded file
      } catch (error) {
        console.error('Failed to load Markdown:', error);
        contentWrapperDiv.innerHTML = `<p style="color:red; font-weight:bold;">Failed to load content for "${filePath}".</p><p style="color:var(--text);">Error: ${error.message}</p><p>Please check the console for more details.</p>`;
      }
    }

    // Handles URL hash changes for navigation
    function onHashChange() {
      let hash = decodeURIComponent(location.hash.slice(1));

      if (!hash) { // If no hash, load default README.md
        hash = 'README.md';
        history.replaceState(null, '', '#' + hash); // Update URL without triggering hashchange
      }

      const hashParts = hash.split('#');
      const filePathFromHash = hashParts[0]; // This is the path to the .md file

      if (filePathFromHash && filePathFromHash.toLowerCase().endsWith('.md')) {
        // If the file path from hash is different from currentFile, load it.
        // Or, if it's the same file but currentFile is null (initial load), load it.
        if (filePathFromHash !== currentFile || currentFile === null) {
          loadMarkdown(filePathFromHash);
        } else {
          // Same file is already loaded, just handle scrolling to section if specified
          const sectionHashPart = hashParts.length > 1 ? hashParts[1] : '';
          if (sectionHashPart) {
            const elementToScroll = contentWrapperDiv.querySelector('#' + generateValidId(sectionHashPart));
            if (elementToScroll && contentWrapperDiv.contains(elementToScroll)) {
              elementToScroll.scrollIntoView({ behavior: 'smooth' });
            } else {
                 console.warn(`Element with ID #${generateValidId(sectionHashPart)} not found for same-file scroll in ${filePathFromHash}.`);
                 contentDiv.scrollTop = 0; // Scroll to top if section not found
            }
          } else {
            contentDiv.scrollTop = 0; // Scroll to top if no internal hash for the same file
          }
        }
      } else if (filePathFromHash) { // If hash is not an .md file but exists
        console.warn(`Invalid or non-Markdown file path in hash: "${filePathFromHash}". Loading default README.md`);
        history.replaceState(null, '', '#README.md');
        loadMarkdown('README.md');
      }
      // If filePathFromHash is empty (e.g. URL is just `#`), it defaults to README.md due to the `!hash` check earlier.
    }

    // Ensure sidebar links and badge links are correctly formatted for external targets
    document.querySelectorAll('#sidebar a, .md-badges a').forEach(link => {
        const href = link.getAttribute('href');
        if (href && (href.startsWith('http://') || href.startsWith('https://'))) {
            // Check if it's not already targeting _blank and not an internal SPA link
            if (!link.hasAttribute('target') || link.getAttribute('target') !== '_blank') {
                try {
                    const linkUrl = new URL(link.href); // Use link.href to get absolute URL
                    const currentLocUrl = new URL(window.location.href);
                    if (linkUrl.hostname !== currentLocUrl.hostname || linkUrl.protocol !== currentLocUrl.protocol) {
                        link.setAttribute('target', '_blank');
                        link.setAttribute('rel', 'noopener noreferrer');
                    }
                } catch (e) {
                    console.error("Error processing link URL for target='_blank':", href, e);
                     link.setAttribute('target', '_blank');
                     link.setAttribute('rel', 'noopener noreferrer');
                }
            }
        }
    });


    // Event listeners for page load and hash changes
    window.addEventListener('hashchange', onHashChange);
    window.addEventListener('load', () => {
      if (typeof hljs !== 'undefined') {
        // Ensure highlight.js is available before calling
        hljs.configure({ ignoreUnescapedHTML: true }); // Optional: good for robustness
        // Initial highlighting might be better done after first loadMarkdown completes
      }
      onHashChange(); // Initial content load based on hash or default
    });
  </script>
</body>
</html>
